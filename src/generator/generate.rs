use std::rc::Rc;

use indoc::formatdoc;
use itertools::Itertools;
use nom::AsChar;

use crate::PluginConfig;
use crate::config::PluginName;
use crate::generator::context::Context;
use crate::generator::state_defs::generate_all_state_definitions;
use crate::models::{DefinedStates, StateNode};
use crate::parsing::{ParseNode, parse_states_text};
use crate::tree::SubTree;

pub(super) const REQUIRED_DERIVES: &[&str] =
    &["Hash", "Default", "Debug", "Clone", "PartialEq", "Eq"];

pub trait ToStringWith {
    fn to_string_indented<S: AsRef<str>>(&self, join: S) -> String;
}

pub fn get_package_info() -> String {
    let pkg = env!("CARGO_PKG_NAME");
    #[cfg(not(test))]
    let version = env!("CARGO_PKG_VERSION");
    #[cfg(test)]
    let version = "[CARGO_PKG_VERSION]";
    format!("{pkg} v{version}")
}

pub fn generate_debug_info(src_path: &str, source: &str) -> String {
    let lines = source.lines().map(|line| format!("// {line}")).join("\n");
    let pkg_info = get_package_info();
    formatdoc! {"
        // generated by {pkg_info}
        // src: {src_path}
        {lines}
    "}
}

pub(crate) fn generate_plugin_source_from_defined_states(
    defined_states: DefinedStates,
    config: PluginConfig,
) -> String {
    let PluginConfig {
        plugin_name,
        root_state_name,
        states_module_name,
        naming_scheme,
        additional_derives,
    } = config;

    let mut context = Context::from(naming_scheme);
    for derive in additional_derives {
        context.derives.push(derive.to_string());
    }

    let type_definitions = generate_all_state_definitions(defined_states, context);
    let definitions_source = type_definitions.to_string_indented("    ");

    let plugin_builder = if let Some(root_state_name) = root_state_name {
        let init_state = format!(".init_state::<{states_module_name}::{root_state_name}>()");
        let sub_states = type_definitions
            .inner()
            .into_iter()
            .skip(1) // skip root
            .map(|typedef| typedef.typename)
            .map(|state_name| format!(".add_sub_state::<{states_module_name}::{state_name}>()"))
            .join("\n            ");
        format!("app{init_state}{sub_states};")
    } else {
        let states = type_definitions
            .inner()
            .into_iter()
            .map(|sdef| {
                if sdef.parent_name.is_some() {
                    let state_name = sdef.typename;
                    format!(".add_sub_state::<{states_module_name}::{state_name}>()")
                } else {
                    let state_name = sdef.typename;
                    format!(".init_state::<{states_module_name}::{state_name}>()")
                }
            })
            .join("\n            ");
        format!("app{states};")
    };

    let plugin_def = match plugin_name {
        PluginName::Struct(plugin_name) => {
            formatdoc! {"
                pub struct {plugin_name};
                impl bevy::app::Plugin for {plugin_name} {{
                    fn build(&self, app: &mut bevy::app::App) {{
                        {plugin_builder}
                    }}
                }}
            "}
        }
        PluginName::Function(plugin_name) => {
            formatdoc! {"
                pub fn {plugin_name}(app: &mut bevy::app::App) {{
                    {plugin_builder}
                }}
            "}
        }
    };

    formatdoc! {"
        #![allow(missing_docs)]
        use bevy::prelude::AppExtStates;
        pub mod {states_module_name} {{
            use bevy::prelude::StateSet;
            {definitions_source}
        }}
        {plugin_def}
    "}
}

#[cfg(feature = "rustfmt")]
fn try_format_source(source: &str) -> std::io::Result<String> {
    duct::cmd!("rustfmt")
        .stdin_bytes(source)
        .stderr_to_stdout()
        .read()
}

pub(crate) fn format_source<S: AsRef<str>>(source: S) -> String {
    let source = source.as_ref();
    #[cfg(feature = "rustfmt")]
    let source = try_format_source(source).unwrap_or_else(|_| source.to_owned());
    #[cfg(not(feature = "rustfmt"))]
    let source = source.to_owned();

    if source.ends_with(|c: char| c.is_newline()) {
        source
    } else {
        source + "\n"
    }
}

pub fn generate_state_plugin_source(
    source: &str,
    plugin_config: PluginConfig,
    src_path: Option<&str>,
) -> Result<String, String> {
    let parse_nodes = parse_states_text(source).map_err(|e| e.to_string())?;
    let defined_states = if let Some(ref root_state_name) = plugin_config.root_state_name {
        let root_state_name = root_state_name.to_string();
        let parse_tree = if parse_nodes.is_empty() {
            ParseNode::singleton(root_state_name.as_str())
        } else {
            ParseNode::enumeration(root_state_name.as_str(), parse_nodes)
        };
        let parse_tree_size = parse_tree.get_tree_size();
        let root_node: Rc<StateNode> = parse_tree
            .try_into_state_node()
            .map(Rc::new)
            .map_err(|e| format!("{e:?}"))?;
        let state_tree_size = root_node.get_tree_size();

        if state_tree_size > parse_tree_size {
            return Err("state-tree exceeds parse-tree!".into());
        }

        DefinedStates::Root(root_node)
    } else {
        DefinedStates::Unrelated(
            parse_nodes
                .into_iter()
                .map(|node| node.try_into_state_node())
                .collect::<Result<Vec<_>, _>>()
                .unwrap(),
        )
    };

    let plugin_source = generate_plugin_source_from_defined_states(defined_states, plugin_config);
    let source = if let Some(src_path) = src_path {
        let debug_info = generate_debug_info(src_path, source);
        [debug_info, plugin_source].join("\n")
    } else {
        plugin_source
    };

    Ok(format_source(source))
}
