use itertools::Itertools;
use lazy_regex::regex;

use crate::generate::get_package_info;
use crate::{NamingScheme, PluginConfig};

pub(crate) fn parse_template_header<'a>(
    source: &'a str,
    plugin_config: &mut PluginConfig,
) -> (String, Vec<&'a str>, Vec<String>) {
    let comment_block = source
        .lines()
        .take_while(|line| line.starts_with("//"))
        .collect_vec();

    let mut info_and_warnings = Vec::new();
    info_and_warnings.push(format!("generated by {}", get_package_info()));

    macro_rules! warn {
        ($($exprs:expr),*) => {
            let warning = format!($($exprs),*);
            let warning = format!("WARN: {warning}");
            eprintln!("{warning}");
            info_and_warnings.push(warning);
        };
    }

    let mut template_src = Vec::new();
    let mut in_template = false;
    let comment_block = comment_block.iter().filter(|line|{
        if in_template {
            if let Some(line) = line.strip_prefix("//") {
                template_src.push(line.trim());
                true
            } else {
                false
            }
        } else if let Some(captures) = regex!(r#"^\s*//\s*bspg:(\w+)\s+(\w+)\s*$"#).captures(line) {
            let (_, [name, value]) = captures.extract();
            match name {
                "root_state_name" => {
                    plugin_config.root_state_name = Some(value.into());
                }
                "naming_scheme" => {
                    if let Some(naming_scheme) = NamingScheme::try_parse(value) {
                        plugin_config.naming_scheme = naming_scheme;
                    } else {
                        warn!(
                            "invalid naming scheme '{value}', expected one of [none, short, full]"
                        );
                    }
                }
                _ => {
                    warn!("unknown setting: '{name}'");
                }
            }
            true
        } else if regex!(r#"^\s*//\s*bspg:\s*$"#).is_match(line) {
            in_template = true;
            true
        } else {
            false
        }
    }).copied().collect_vec();
    (template_src.join("\n"), comment_block, info_and_warnings)
}

#[cfg(test)]
mod tests {
    use bevy_utils::default;
    use indoc::formatdoc;
    use insta::assert_debug_snapshot;
    use rstest::rstest;

    use crate::PluginConfig;
    use crate::parsing::header::parse_template_header;

    #[rstest]
    #[case(String::new())]
    #[case::ignore_first_lines(formatdoc! {"
            // generated by v[CARGO_PKG_VERSION]
            // WARN: some warning
    "})]
    fn test_parse_template_header(#[case] header: String) {
        use insta::allow_duplicates;

        let mut config: PluginConfig = default();
        let (a, b, c) = parse_template_header(&header, &mut config);
        allow_duplicates!(assert_debug_snapshot!((a, b, c, config), @r#"
    (
        "",
        [],
        [
            "generated by bevy_state_plugin_generator v[CARGO_PKG_VERSION]",
        ],
        PluginConfig {
            plugin_name: Struct(
                "GeneratedStatesPlugin",
            ),
            root_state_name: Some(
                "GameState",
            ),
            states_module_name: "states",
            naming_scheme: Full,
            additional_derives: [],
        },
    )
    "#));
    }

    #[rstest]
    fn test_parse_template_header_variables() {
        let mut config: PluginConfig = default();
        let header = formatdoc! {"
        // generated by v[CARGO_PKG_VERSION]
        // bspg:root_state_name None
        // bspg:naming_scheme   Full
        // bspg:
        "};
        let (a, b, c) = parse_template_header(&header, &mut config);
        assert_debug_snapshot!((a, b, c, config), @r#"
        (
            "",
            [
                "// bspg:root_state_name None",
                "// bspg:naming_scheme   Full",
                "// bspg:",
            ],
            [
                "generated by bevy_state_plugin_generator v[CARGO_PKG_VERSION]",
            ],
            PluginConfig {
                plugin_name: Struct(
                    "GeneratedStatesPlugin",
                ),
                root_state_name: Some(
                    "None",
                ),
                states_module_name: "states",
                naming_scheme: Full,
                additional_derives: [],
            },
        )
        "#);
    }

    #[rstest]
    fn test_parse_template_header_warnings() {
        let mut config: PluginConfig = default();
        let header = formatdoc! {"
        // bspg:my_var 1234
        // bspg:
        // MyState {{ Alpha, Beta }}
        "};
        let (a, b, c) = parse_template_header(&header, &mut config);
        assert_debug_snapshot!((a, b, c, config), @r#"
        (
            "MyState { Alpha, Beta }",
            [
                "// bspg:my_var 1234",
                "// bspg:",
                "// MyState { Alpha, Beta }",
            ],
            [
                "generated by bevy_state_plugin_generator v[CARGO_PKG_VERSION]",
                "WARN: unknown setting: 'my_var'",
            ],
            PluginConfig {
                plugin_name: Struct(
                    "GeneratedStatesPlugin",
                ),
                root_state_name: Some(
                    "GameState",
                ),
                states_module_name: "states",
                naming_scheme: Full,
                additional_derives: [],
            },
        )
        "#);
    }
}
