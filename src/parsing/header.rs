#[cfg(test)]
mod tests;

use std::borrow::Cow;

use itertools::Itertools;
use lazy_regex::regex;

use crate::generate::core::get_package_info;
use crate::prelude::{NamingScheme, PluginConfig, PluginName};

#[derive(Clone, Debug, Default, PartialEq)]
pub(crate) struct TemplateHeader<'a> {
    pub template: Vec<&'a str>,
    pub comments_block: Vec<&'a str>,
    pub info_block: Vec<String>,
}

trait Unquote {
    fn unquoted(&self) -> Self;
}

impl Unquote for &str {
    fn unquoted(&self) -> Self {
        self.strip_prefix("\"")
            .and_then(|s| s.strip_suffix("\""))
            .unwrap_or(self)
    }
}

pub(crate) const SUPPORTED_VARIABLES: &[&str] = &[
    "root_state_name",
    "naming_scheme",
    "plugin_name",
    "states_module_name",
    "additional_derives",
];

pub(crate) fn apply_directive(
    plugin_config: &mut PluginConfig,
    name: &str,
    value: &str,
) -> Option<String> {
    if !SUPPORTED_VARIABLES.contains(&name) {
        return Some(format!("unknown setting: '{name}'"));
    }
    match name {
        "root_state_name" => {
            plugin_config.root_state_name = if value == "None" {
                None
            } else {
                Some(Cow::Owned(value.unquoted().to_string()))
            };
        }
        "naming_scheme" => {
            if let Some(naming_scheme) = NamingScheme::try_parse(value) {
                plugin_config.naming_scheme = naming_scheme;
            } else {
                return Some(format!(
                    "invalid naming scheme '{value}' (expected [none, short, full])"
                ));
            }
        }
        "plugin_name" => {
            if let Some(plugin_name) = PluginName::parse(value) {
                let name = (*plugin_name).to_owned();
                plugin_config.plugin_name = PluginName::parse(name).unwrap();
            } else {
                return Some(format!(
                    "invalid plugin name '{value}' (expected [UpperCamelCase, lower_snake_case])"
                ));
            }
        }
        "states_module_name" => {
            plugin_config.states_module_name = Cow::from(value.to_string());
        }
        "additional_derives" => {
            let mut to_add = value
                .split_terminator(",")
                .map(ToString::to_string)
                .map(Cow::Owned)
                .collect_vec();
            plugin_config.additional_derives.append(&mut to_add);
        }
        _ => {
            unreachable!()
        }
    }
    None
}

pub(crate) fn parse_template_header<'a>(
    source: &'a str,
    plugin_config: &mut PluginConfig,
) -> TemplateHeader<'a> {
    let leading_comments = source
        .lines()
        .take_while(|line| line.starts_with("//"))
        .collect_vec();

    let mut info_block = Vec::new();
    info_block.push(format!("generated by {}", get_package_info()));

    macro_rules! emit_warning {
        ($($exprs:expr),*) => {
            let warning = format!($($exprs),*);
            let warning = format!("WARN: {warning}");
            eprintln!("{warning}");
            info_block.push(warning);
        };
    }

    let mut template_source = Vec::new();
    let mut in_template = false;
    let leading_comments = leading_comments
        .iter()
        .filter(|line| {
            if in_template {
                if let Some(line) = line.strip_prefix("//") {
                    template_source.push(line.trim());
                    true
                } else {
                    false
                }
            } else if let Some(captures) =
                regex!(r#"^\s*//\s*bspg:(\w+)\s+(\w+|"\w+\")\s*$"#).captures(line)
            {
                let (_, [name, value]) = captures.extract();
                if let Some(warning) = apply_directive(plugin_config, name, value) {
                    emit_warning!("{warning}");
                }
                true
            } else if regex!(r#"^\s*//\s*bspg:\s*$"#).is_match(line) {
                in_template = true;
                true
            } else {
                eprintln!("dropping: '{line:?}'");
                false
            }
        })
        .copied()
        .collect_vec();
    TemplateHeader {
        template: template_source,
        comments_block: leading_comments,
        info_block,
    }
}
