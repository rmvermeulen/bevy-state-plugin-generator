use itertools::Itertools;
use lazy_regex::regex;

use crate::generate::get_package_info;
use crate::{NamingScheme, PluginConfig};

#[derive(Clone, Debug, Default, PartialEq)]
pub(crate) struct TemplateHeader<'a> {
    pub template: Vec<&'a str>,
    pub comments_block: Vec<&'a str>,
    pub info_block: Vec<String>,
}

trait Unquote {
    fn unquoted(&self) -> Self;
}

impl Unquote for &str {
    fn unquoted(&self) -> Self {
        self.strip_prefix("\"")
            .and_then(|s| s.strip_suffix("\""))
            .unwrap_or(self)
    }
}

pub(crate) fn parse_template_header<'a>(
    source: &'a str,
    plugin_config: &mut PluginConfig,
) -> TemplateHeader<'a> {
    let leading_comments = source
        .lines()
        .take_while(|line| line.starts_with("//"))
        .collect_vec();

    let mut info_block = Vec::new();
    info_block.push(format!("generated by {}", get_package_info()));

    macro_rules! warn {
        ($($exprs:expr),*) => {
            let warning = format!($($exprs),*);
            let warning = format!("WARN: {warning}");
            eprintln!("{warning}");
            info_block.push(warning);
        };
    }

    let mut template_source = Vec::new();
    let mut in_template = false;
    let leading_comments = leading_comments
        .iter()
        .filter(|line| {
            if in_template {
                if let Some(line) = line.strip_prefix("//") {
                    template_source.push(line.trim());
                    true
                } else {
                    false
                }
            } else if let Some(captures) =
                regex!(r#"^\s*//\s*bspg:(\w+)\s+(\w+|"\w+\")\s*$"#).captures(line)
            {
                let (_, [name, value]) = captures.extract();
                match name {
                    "root_state_name" => {
                        plugin_config.root_state_name = if value == "None" {
                            None
                        } else {
                            Some(value.unquoted().to_string())
                        };
                    }
                    "naming_scheme" => {
                        if let Some(naming_scheme) = NamingScheme::try_parse(value) {
                            plugin_config.naming_scheme = naming_scheme;
                        } else {
                            warn!("invalid naming scheme '{value}' (expected [none, short, full])");
                        }
                    }
                    _ => {
                        warn!("unknown setting: '{name}'");
                    }
                }
                true
            } else if regex!(r#"^\s*//\s*bspg:\s*$"#).is_match(line) {
                in_template = true;
                true
            } else {
                eprintln!("dropping: '{line:?}'");
                false
            }
        })
        .copied()
        .collect_vec();
    TemplateHeader {
        template: template_source,
        comments_block: leading_comments,
        info_block,
    }
}

#[cfg(test)]
mod tests {
    use bevy_utils::default;
    use indoc::formatdoc;
    use rstest::rstest;
    use speculoos::assert_that;
    use speculoos::prelude::{ContainingIntoIterAssertions, VecAssertions};

    use crate::parsing::header::parse_template_header;
    use crate::{NamingScheme, PluginConfig};

    #[rstest]
    #[case(String::new())]
    #[case::ignore_generated_lines(formatdoc! {"
        // generated by v[CARGO_PKG_VERSION]
        // WARN: some warning
    "})]
    fn test_parse_template_header(#[case] header: String) {
        let mut config: PluginConfig = default();
        let header = parse_template_header(&header, &mut config);
        assert_that!(header.template).is_empty();
        assert_that!(header.comments_block).is_empty();
    }

    #[rstest]
    fn test_parse_template_header_keep_variables() {
        let header = formatdoc! {"
            // generated by v[CARGO_PKG_VERSION]
            // WARN: some warning
            // bspg:some setting
        "};
        let mut config: PluginConfig = default();
        let header = parse_template_header(&header, &mut config);
        assert_that!(header.comments_block).contains("// bspg:some setting");
        assert_that!(header.info_block).contains("WARN: unknown setting: 'some'".to_string());
    }

    #[rstest]
    fn test_parse_template_header_variable_values(
        #[values(NamingScheme::Full, NamingScheme::None, NamingScheme::Short)]
        naming_scheme: NamingScheme,
        #[values(None, Some("MyStateRoot"))] name: Option<&str>,
    ) {
        let mut config: PluginConfig = default();
        let header = formatdoc! {"
            // generated by v[CARGO_PKG_VERSION]
            // bspg:root_state_name {}
            // bspg:naming_scheme   {}
            // bspg:
            ",
            name.map(|name| format!("\"{name}\"")).unwrap_or("None".to_string()),
            naming_scheme
        };
        let _ = parse_template_header(&header, &mut config);
        assert_that!(config.root_state_name).is_equal_to(name.map(String::from));
        assert_that!(config.naming_scheme).is_equal_to(naming_scheme);
    }
}
