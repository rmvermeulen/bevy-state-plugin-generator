use bevy_reflect::Struct;
use bevy_utils::default;
use indoc::formatdoc;
use itertools::Itertools;
use rstest::rstest;
use speculoos::assert_that;
use speculoos::prelude::{ContainingIntoIterAssertions, VecAssertions};

use crate::parsing::header::{SUPPORTED_VARIABLES, parse_template_header};
use crate::prelude::{NamingScheme, PluginConfig};

#[rstest]
#[case(String::new())]
#[case::ignore_generated_lines(formatdoc! {"
    // generated by v[CARGO_PKG_VERSION]
    // WARN: some warning
"})]
fn test_parse_template_header(#[case] header: String) {
    let mut config: PluginConfig = default();
    let header = parse_template_header(&header, &mut config);
    assert_that!(header.template).is_empty();
    assert_that!(header.comments_block).is_empty();
}

#[rstest]
fn test_parse_template_header_keep_variables() {
    let header = formatdoc! {"
        // generated by v[CARGO_PKG_VERSION]
        // WARN: some warning
        // bspg:some setting
    "};
    let mut config: PluginConfig = default();
    let header = parse_template_header(&header, &mut config);
    assert_that!(header.comments_block)
        .is_equal_to(header.comments_block.iter().copied().unique().collect_vec());
    assert_that!(header.comments_block).contains("// bspg:some setting");
    assert_that!(header.info_block).contains("WARN: unknown setting: 'some'".to_string());
}

#[rstest]
fn test_parse_template_header_variable_values(
    #[values(NamingScheme::Full, NamingScheme::None, NamingScheme::Short)]
    naming_scheme: NamingScheme,
    #[values(None, Some("MyStateRoot"))] name: Option<&str>,
) {
    let mut config: PluginConfig = default();
    let header = formatdoc! {"
        // generated by v[CARGO_PKG_VERSION]
        // bspg:root_state_name {}
        // bspg:naming_scheme   {}
        // bspg:
        ",
        name.map(|name| format!("\"{name}\"")).unwrap_or("None".to_string()),
        naming_scheme
    };
    let _ = parse_template_header(&header, &mut config);
    assert_that!(config.root_state_name.as_ref().map(ToString::to_string))
        .is_equal_to(name.map(String::from));
    assert_that!(config.naming_scheme).is_equal_to(naming_scheme);
}

#[rstest]
fn test_plugin_config_all_fields_supported_as_variables() {
    let config = PluginConfig::default();
    let info = config.get_represented_struct_info().unwrap();
    assert_that!(info.field_names().to_vec()).contains_all_of(&SUPPORTED_VARIABLES);
}

#[rstest]
fn test_parse_template_header_all_variables_supported() {}
