use std::borrow::Cow;

use bevy_reflect::Struct;
use bevy_utils::default;
use indoc::formatdoc;
use insta::assert_snapshot;
use itertools::Itertools;
use rstest::rstest;
use speculoos::assert_that;
use speculoos::prelude::{ContainingIntoIterAssertions, OptionAssertions, VecAssertions};

use crate::parsing::header::{SUPPORTED_VARIABLES, apply_directive, parse_template_header};
use crate::prelude::{NamingScheme, PluginConfig, PluginName};

#[rstest]
#[case(String::new())]
#[case::ignore_generated_lines(formatdoc! {"
    // generated by v[CARGO_PKG_VERSION]
    // WARN: some warning
"})]
fn test_parse_template_header(#[case] header: String) {
    let mut config: PluginConfig = default();
    let header = parse_template_header(&header, &mut config);
    assert_that!(header.template).is_empty();
    assert_that!(header.comments_block).is_empty();
}

#[rstest]
fn test_parse_template_header_keep_variables() {
    let header = formatdoc! {"
        // generated by v[CARGO_PKG_VERSION]
        // WARN: some warning
        // bspg:some setting
    "};
    let mut config: PluginConfig = default();
    let header = parse_template_header(&header, &mut config);
    assert_that!(header.comments_block)
        .is_equal_to(header.comments_block.iter().copied().unique().collect_vec());
    assert_that!(header.comments_block).contains("// bspg:some setting");
    assert_that!(header.info_block).contains("WARN: unknown setting: 'some'".to_string());
}

#[rstest]
fn test_parse_template_header_variable_values(
    #[values(NamingScheme::Full, NamingScheme::None, NamingScheme::Short)]
    naming_scheme: NamingScheme,
    #[values(None, Some("MyStateRoot"))] name: Option<&str>,
) {
    let mut config: PluginConfig = default();
    let header = formatdoc! {"
        // generated by v[CARGO_PKG_VERSION]
        // bspg:root_state_name {}
        // bspg:naming_scheme   {}
        // bspg:
        ",
        name.map(|name| format!("\"{name}\"")).unwrap_or("None".to_string()),
        naming_scheme
    };
    let _ = parse_template_header(&header, &mut config);
    assert_that!(config.root_state_name.as_ref().map(ToString::to_string))
        .is_equal_to(name.map(String::from));
    assert_that!(config.naming_scheme).is_equal_to(naming_scheme);
}

#[rstest]
fn test_plugin_config_all_fields_supported_as_variables() {
    let config = PluginConfig::default();
    let info = config.get_represented_struct_info().unwrap();
    assert_that!(info.field_names().to_vec()).contains_all_of(&SUPPORTED_VARIABLES);
}

#[rstest]
fn test_parse_template_header_root_state_name() {
    let mut plugin_config = PluginConfig::default();
    let warning = apply_directive(&mut plugin_config, "root_state_name", "Bob");
    assert_that!(warning).is_none();
    assert_that!(
        plugin_config
            .root_state_name
            .as_ref()
            .map(ToString::to_string)
            .unwrap_or_default()
    )
    .is_equal_to("Bob".to_string());
}

#[rstest]
fn test_parse_template_header_states_module_name() {
    let mut plugin_config = PluginConfig::default();
    let warning = apply_directive(&mut plugin_config, "states_module_name", "Bob");
    assert_that!(warning).is_none();
    assert_that!(plugin_config.states_module_name.unwrap().as_ref()).is_equal_to("Bob");
}

#[rstest]
#[case("full", NamingScheme::Full, false)]
#[case("Full", NamingScheme::Full, false)]
#[case("short", NamingScheme::Short, false)]
#[case("Short", NamingScheme::Short, false)]
#[case("none", NamingScheme::None, false)]
#[case("None", NamingScheme::None, false)]
#[case("invalid input", NamingScheme::default(), true)]
fn test_parse_template_header_naming_scheme(
    #[case] input: &str,
    #[case] expected: NamingScheme,
    #[case] expected_warning: bool,
) {
    let mut plugin_config = PluginConfig::default();
    let warning = apply_directive(&mut plugin_config, "naming_scheme", input);
    if expected_warning {
        assert_snapshot!(
            warning.unwrap(),
            @"invalid naming scheme 'invalid input' (expected [none, short, full])");
    } else {
        assert_that!(warning).is_none();
    };
    assert_that!(plugin_config.naming_scheme).is_equal_to(expected);
}

#[rstest]
fn test_parse_template_header_additional_derives() {
    let mut plugin_config = PluginConfig::default();
    let warning = apply_directive(&mut plugin_config, "additional_derives", "Alice,Bob");
    assert_that!(warning).is_none();
    assert_that!(plugin_config.additional_derives).contains_all_of(&[
        &Cow::from("Alice".to_string()),
        &Cow::from("Bob".to_string()),
    ]);
}

#[rstest]
#[case("StructPlugin", PluginName::new_struct("StructPlugin"))]
#[case("fn_plugin", PluginName::new_function("fn_plugin"))]
fn test_parse_template_header_plugin_name(
    #[case] plugin_name: &str,
    #[case] expected_plugin_name: PluginName,
) {
    let mut plugin_config = PluginConfig::default();
    let warning = apply_directive(&mut plugin_config, "plugin_name", plugin_name);
    assert_that!(warning).is_none();
    assert_that!(plugin_config.plugin_name).is_equal_to(expected_plugin_name);
}
