use indoc::formatdoc;
use std::{io, rc::Rc};

use iter_tools::Itertools;

use crate::model::{SourceState, StateNode, SubTree};
use crate::parser::parse_states_file;
use crate::{NamingScheme, PluginConfig};

#[cfg(test)]
mod tests;

fn generate_all_type_definitions(
    source_state: Option<SourceState>,
    root_node: &StateNode,
    scheme: NamingScheme,
) -> String {
    const DERIVES: &str = "Hash, Default, Debug, Clone, PartialEq, Eq";
    let typename = if scheme == NamingScheme::None {
        root_node.name().to_string()
    } else {
        source_state
            .clone()
            .map(|source_state| format!("{}{}", source_state.name(), root_node.name()))
            .unwrap_or_else(|| root_node.name().to_string())
    };
    let root_typedef = {
        let derives = source_state
            .clone()
            .map(|source_state| {
                let source = source_state.name();
                let variant = source_state.name_and_variant();
                [
                    format!("#[derive(bevy::prelude::SubStates, {DERIVES})]"),
                    format!("#[source({source} = {variant})]"),
                ]
                .join("\n")
            })
            .unwrap_or(format!("#[derive(bevy::prelude::States, {DERIVES})]"));

        match root_node {
            #[cfg(feature = "lists")]
            StateNode::List(_, _) => {
                format!("{derives}\npub struct {typename};")
            }
            StateNode::Singleton(_) => {
                format!("{derives}\npub struct {typename};")
            }
            StateNode::Enum(_, variants) => {
                let variants = variants.iter().map(|variant| variant.name()).join(", ");
                format!("{derives}\npub enum {typename} {{ #[default] {variants} }}")
            }
        }
    };
    match root_node {
        StateNode::Singleton(_) => root_typedef,
        StateNode::Enum(_, variants) => {
            let root_name = root_node.name().to_string();
            let variants = variants
                .iter()
                .map(|child_node| {
                    generate_all_type_definitions(
                        Some(SourceState {
                            name: match scheme {
                                NamingScheme::Short | NamingScheme::None => root_name.clone(),
                                NamingScheme::Full => typename.clone(),
                            },
                            variant: child_node.name().to_string(),
                        }),
                        child_node,
                        scheme,
                    )
                })
                .join("\n");
            format!("{root_typedef}\n\n{variants}")
        }
        #[cfg(feature = "lists")]
        StateNode::List(_, variants) => variants
            .iter()
            .map(|child_node| {
                generate_all_type_definitions(
                    Some(SourceState {
                        name: typename.clone(),
                        variant: child_node.name().to_string(),
                    }),
                    child_node,
                    scheme,
                )
            })
            .join("\n"),
    }
}

pub fn generate_debug_info(src_path: &str, source: &str) -> String {
    let pkg = env!("CARGO_PKG_NAME");
    let version = env!("CARGO_PKG_VERSION");
    let lines = source.lines().map(|line| format!("// {line}")).join("\n");
    formatdoc! {"
        // generated by {pkg} v{version}
        // src: {src_path}
        {lines}
    "}
}

pub(crate) fn generate_plugin_source(root_state: Rc<StateNode>, config: PluginConfig) -> String {
    let PluginConfig {
        plugin_name,
        state_name,
        states_module_name,
        scheme: _,
    } = config;

    let header = r#"
        #![allow(missing_docs)]
        use bevy::prelude::AppExtStates;
    "#;
    let plugin = {
        let struct_decl = format!("pub struct {plugin_name};");
        let impl_block = format!("impl bevy::app::Plugin for {plugin_name}");
        let init = format!("app.init_state::<{states_module_name}::{state_name}>();");
        let build_fn = format!("fn build(&self, app: &mut bevy::app::App) {{ {init} }}");
        format!("{struct_decl}\n{impl_block} {{ {build_fn} }}")
    };
    let states_module = format!(
        "pub mod {states_module_name} {{ use bevy::prelude::StateSet; {type_definitions} }}",
        type_definitions = generate_all_type_definitions(None, &root_state, config.scheme),
    );
    [header, &states_module, &plugin].join("\n")
}

#[cfg(feature = "rustfmt")]
pub fn try_format_source(source: &str) -> io::Result<String> {
    duct::cmd!("rustfmt")
        .stdin_bytes(source)
        .stderr_to_stdout()
        .read()
}

pub fn format_source<S: AsRef<str>>(source: S) -> String {
    let source = source.as_ref();
    #[cfg(feature = "rustfmt")]
    {
        try_format_source(source).unwrap_or_else(|_| source.to_owned())
    }
    #[cfg(not(feature = "rustfmt"))]
    {
        source.to_owned()
    }
}

pub fn generate_state_plugin_source<P: AsRef<str> + std::fmt::Display, S: AsRef<str>>(
    src_path: P,
    source: S,
    plugin_config: PluginConfig,
) -> Result<String, String> {
    let source = source.as_ref();
    let parse_tree =
        parse_states_file(source, plugin_config.state_name).map_err(|e| e.to_string())?;

    let parse_tree_size = parse_tree.get_tree_size();

    let root_node: Rc<StateNode> = parse_tree
        .try_into()
        .map(Rc::new)
        .map_err(|e| format!("{e:?}"))?;
    let state_tree_size = root_node.get_tree_size();

    assert_eq!(parse_tree_size, state_tree_size);

    let debug_info = generate_debug_info(src_path.as_ref(), source);
    let plugin_source = generate_plugin_source(root_node, plugin_config);
    let source = [debug_info, plugin_source].join("\n");

    Ok(format_source(source))
}
