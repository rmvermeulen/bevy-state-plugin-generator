---
source: src/generate/tests.rs
expression: "generate_state_plugin_source(source, default(), Some(src_path)).unwrap()"
---
// generated by bevy_state_plugin_generator v[CARGO_PKG_VERSION]
// src: alpabet.txt
// A B C D E F G H I

use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::A)]
pub struct A;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::A>();
    }
}


use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::B)]
pub struct B;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::B>();
    }
}


use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::C)]
pub struct C;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::C>();
    }
}


use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::D)]
pub struct D;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::D>();
    }
}


use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::E)]
pub struct E;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::E>();
    }
}


use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::F)]
pub struct F;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::F>();
    }
}


use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::G)]
pub struct G;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::G>();
    }
}


use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::H)]
pub struct H;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::H>();
    }
}


use bevy::prelude::AppExtStates;
#[allow(missing_docs)]
pub mod states {
    use bevy::prelude::StateSet;
    #[derive(bevy::prelude::States, Hash, Default, Debug, Clone, PartialEq, Eq)]
pub struct GameState;

#[derive(bevy::prelude::SubStates, Hash, Default, Debug, Clone, PartialEq, Eq)]
#[source(GameState = GameState::I)]
pub struct I;

}
pub struct GeneratedStatesPlugin;
impl bevy::app::Plugin for GeneratedStatesPlugin {
    fn build(&self, app: &mut bevy::app::App) {
        app.init_state::<states::GameState>().add_sub_state::<states::I>();
    }
}
